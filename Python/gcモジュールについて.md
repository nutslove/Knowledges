## Pythonのメモリ管理の２つのメカニズムについて
### 1. 参照カウント方式
- Pythonのメインのメモリ管理方式
- 各オブジェクトは「自分が何箇所から参照されているか」をカウントしており、このカウントが0になると**即座に**メモリが解放される
- **これは`gc`モジュールとは別の仕組みで、Pythonインタプリタが自動的に行っている**

### 2. 世代別GC（Generational GC）
- 循環参照を解決するために、Pythonは世代別GCを併用している
- 循環参照とは、オブジェクトAがオブジェクトBを参照し、オブジェクトBがオブジェクトAを参照しているような状態
- 参照カウント方式では、こうしたオブジェクトはお互いに参照カウントが減らないため、メモリが解放されない
- 世代別GCは、定期的にメモリをスキャンして、こうした循環参照を検出し、不要なオブジェクトを回収する
- オブジェクトを「世代（0, 1, 2）」に分けて管理
  - 第0世代: 作られたばかりのオブジェクト
  - 第1世代: 第0世代の回収を生き残ったオブジェクト
  - 第2世代: 長期間生き残っているオブジェクト
- **`gc`モジュールは、この世代別GCの制御やデバッグを行うためのインターフェースを提供している**
- **世代別GCもPythonが自動的に管理してくれるので、通常は`gc`モジュールを直接操作する必要はない**

---

## `gc`モジュールの主な用途
> [!NOTE]  
> `gc`モジュールで制御できるのは**世代別GCのみ**（参照カウント方式は常に動作）

### ガベージコレクションの制御
- メモリの自動解放を手動で制御できる
  - `gc.enable()`: 自動ガベージコレクションを有効にする
  - `gc.disable()`: 自動ガベージコレクション（世代別GC）を無効にする
    - ※参照カウント方式は引き続き動作する
  - `gc.collect()`: ガベージコレクションを手動で実行する
  - `gc.isenabled()`: 自動ガベージコレクションが有効かどうかを確認する
- 例  
  ```python
  import gc
  gc.disable()  # ガベージコレクションを無効化
  # メモリ集中的な処理
  gc.enable()  # ガベージコレクションを再度有効化
  gc.collect()  # 手動でガベージコレクションを実行
  ```
### メモリリークのデバッグ
- 循環参照などでメモリリークが発生している場合に、オブジェクトの追跡やデバッグが可能
  - `gc.get_objects()`: GC管理下の現在のすべてのオブジェクトを取得する
  - `gc.get_referrers(obj)`: 指定したオブジェクト**を**参照しているオブジェクトを取得する
  - `gc.get_referents(obj)`: 指定したオブジェクト**が**参照しているオブジェクトを取得する
- 例  
  ```python
  import gc

  gc.set_debug(gc.DEBUG_LEAK)
  # ... 問題のあるコード ...
  gc.collect()
  print(gc.garbage)  # 回収できなかったオブジェクト
  ```

  ```python
  import gc

  # GC管理下の全オブジェクトを取得
  all_objects = gc.get_objects()
  print(f"Total objects: {len(all_objects)}")

  # 特定オブジェクトを参照しているオブジェクトを取得
  my_list = [1, 2, 3]
  referrers = gc.get_referrers(my_list)

  # 特定オブジェクトが参照しているオブジェクトを取得
  referents = gc.get_referents(my_list)
  ```
