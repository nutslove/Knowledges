## Ruler
- 参考URL
  - https://grafana.com/docs/loki/latest/operations/recording-rules/
  - https://grafana.com/docs/loki/latest/alert/#recording-rules
- logデータに対して、定期的にクエリーを実行し、アラートの発行やメトリクスの記録（Recording）を行うコンポーネント
- アラートの場合は、Alertmanagerにアラートを送信することができる
- Recording時は、Lokiのログデータを元にPrometheusのメトリクスを生成し、Prometheus互換の（Remote Write）エンドポイントに送信することができる
  - **Lokiのログが持っているラベルはPrometheusのメトリクスのラベルとして引き継がれる**
- LokiのRecorind rulesはPrometheusのと同じアーキテクチャ（Prometheusのコードを再利用している）  
  > Since Loki reuses the Prometheus code for recording rules and WALs, it also gains all of Prometheus' observability.

> [!TIP]  
> - Recording Rulesで変換後のメトリクス名の命名規則は強制的なルールはないが、強く推奨されている命名規則がある
> - https://prometheus.io/docs/practices/rules/
> - コロン（`:`）を使って階層を表現 
>   - `level:metric:operations` (e.g. `nginx:requests:rate1m`)
>
> |要素|説明|例|
> |---|---|---|
> |level|集計の粒度（レベル）どの単位で集計したものかを表す|"instance, job, service, cluster, path"|
> |metric|メトリクスの名前もともとの対象となっている指標名|"http_requests_total, cpu_usage_seconds"|
> |operations|適用した操作どのような関数や期間で計算したかを表す|"rate5m, sum, count, max"|

## Helmでの設定例
- `loki.rulerConfig`、`ruler`セクションを設定する必要がある
- **Lokiがマルチテナントモード（`auth_enabled: true`）の場合、`loki.rulerConfig.remote_write`の`add_org_id_header`を`true`に設定する必要がある。これにより、Rulerが送信するRemote Writeリクエストに`X-Scope-OrgID`ヘッダーが自動的に追加される**

> [!NOTE]  
> - マルチテナントモード時、Lokiがクエリー時にどのテナント（`X-Scope-OrgID`ヘッダー）に対してクエリーを実行するかは、`loki/rules`ディレクトリのサブディレクトリ名で決まる
>
> ```yaml
> ruler:
>   storage:
>     type: local
>     local:
>       directory: /loki/rules
> ```
>
> 上記の場合、ディレクトリ名がテナントIDになる：
> ```
> /loki/rules/
> ├── tenant-a/          ← このディレクトリ名がテナントID
> │   └── rules.yaml
> ├── tenant-b/
> │   └── rules.yaml
> ```

> [!IMPORTANT]  
> - **Rulerの評価(evaluation)の間隔と、`rate`や`count_over_time`などの集計関数で使用する時間範囲（`[]`）は一致させることが推奨される**
>   - `interval > range` の場合：データの欠落（ギャップ）が発生
>   - `interval < range` の場合：重複カウント（同じログが複数回集計される）
>   - `interval == range` の場合：ギャップも重複もない
> - defaultの評価間隔は`ruler`blockの`evaluation_interval`で設定できて、初期値は`1m`(1分)
>   - 各rule groupごとに`interval`で上書き可能
> - 例  
> ```yaml
> groups:
>   - name: fast-rules
>     interval: 30s
>     rules:
>       - record: loki:critical_errors:30s
>         expr: sum(rate({level="error"} [30s]))
>
>   - name: slow-rules
>     interval: 5m
>     rules:
>       - record: loki:total_logs:5m
>         expr: sum(count_over_time({job="app"} [5m]))
> ```

> [!IMPORTANT]  
> - Helmはrulesファイルを`/etc/loki/rules`にConfigMapとしてマウントするため、`loki.rulerConfig.storage.local.directory`は`/etc/loki/rules`に設定する必要がある
> - `rule_path`は書き込み可能なパスである必要があるため、`/tmp/loki/rules-temp`などの書き込み可能なパスを指定する必要がある。`/etc/loki/rules`は読み取り専用なのでNG
>   - https://github.com/grafana/loki/issues/13027  
>     > When adding custom rules, I can see they are added in /etc/loki/rules in the ruler container, but they are not picked up by Loki. When the rule_path config is set to /etc/loki/rules, Loki tries to delete the directory and fails because it is a read only filesystem. The template for the statefulset mounts the configmap here. 

> [!NOTE]  
> `rule_path`はRulesが格納されているバックエンドからとってきて、Rulerが実際に読み取って実行するために一時的に置く作業用ディレクトリ（なのでWrite権限が必要）
> - https://dbadbadba.com/blog/finocchiaro-loki  
>   > rule_path is the output of the temp rule file that is generated when the ruler evaluates the rules file. This location is very important because the loki user on the pod must have write access to that directory.
> 
> |設定項目|役割|性質|
> |---|---|---|
> |`storage.local.directory`|rulesの原本ファイルが格納されている場所|読み取り専用でOK|
> |`rule_path`|Rulerが実際に読み取って実行するために一時的に置く作業用ディレクトリ|書き込み権限が必要|

> [!NOTE]  
> - `wal.dir`はRecording Rulesで生成されたメトリクスサンプルを一時保存するためのWrite-Ahead Log（WAL）のディレクトリ
> - ここにも**書き込み権限が必要**
> - https://grafana.com/docs/loki/latest/operations/recording-rules/#write-ahead-log-wal
>   > All samples generated by recording rules are written to a WAL. The WALs main benefit is that it persists the samples generated by recording rules to disk, which means that if your ruler crashes, you won’t lose any data. We are trading off extra memory usage and slower start-up times for this functionality.
>   >
>   > A WAL is created per tenant; this is done to prevent cross-tenant interactions.
> - Recording Ruleによって生成されたメトリクスは最初にwalに書き込まれ、walから読み取られてRemote Writeエンドポイントに送信される
>   - https://prometheus.io/docs/practices/remote_write/
>
> ```
> Recording Rule評価
>       ↓
>   メトリクス生成
>       ↓
> ┌──────────────────┐
> │  WAL (wal.dir)   │  ← まずここに書き込まれる
> └──────────────────┘
>       ↓
>   WALから読み取り
>       ↓
> ┌──────────────────┐
> │ In-memory Queue  │  ← shardごとのキュー
> │  (per shard)     │
> └──────────────────┘
>       ↓
>   remote_write
>       ↓
>  Prometheus/Thanos
> ```

```yaml
loki:
  auth_enabled: true # default is true
  images:
    tag: "3.5.1"
  schemaConfig:
    configs:
      - from: "2024-04-01"
        store: tsdb
        object_store: s3
        schema: v13
        index:
          prefix: loki_index_
          period: 24h
  tracing:
    enabled: true
  ingester:
    chunk_encoding: snappy
  querier:
    # Default is 4, if you have enough memory and CPU you can increase, reduce if OOMing
    max_concurrent: 4
  pattern_ingester:
    enabled: true
  limits_config:
    retention_period: 720h # 30 days
    allow_structured_metadata: true
    volume_enabled: true
    query_timeout: 3m # Timeout when querying backends (ingesters or storage) during the execution of a query request. Default is 1m. 
  storage:
    type: s3
    s3:
      endpoint: http://minio-dev.minio-dev.svc:9000
      s3: s3://loki-data-bucket
      s3ForcePathStyle: true
      insecure: true
      accessKeyId: minioadmin
      secretAccessKey: minioadmin
    bucketNames:
      chunks: loki-data-bucket
      ruler: loki-ruler-bucket
      admin: loki-admin-bucket
  commonConfig:
    replication_factor: 3
  rulerConfig:
    storage:
      type: local
      local:
        directory: /etc/loki/rules
    wal:
      dir: /tmp/loki/ruler-wal
    rule_path: /tmp/loki/rules-temp # ⚠️ 重要：書き込み可能なパスである必要あり。/etc/loki/rules は読み取り専用なのでNG
    remote_write:
      enabled: true
      add_org_id_header: true  # X-Scope-OrgID を自動付与
      clients:
        default:
          url: http://cortex-tenant:8080/push # X-Scope-OrgID ヘッダーをThanosのTHANOS-TENANTヘッダーに変換してくれるcortex-tenantに送信

deploymentMode: Distributed

gateway:
  replicas: 2
  affinity: # defaultのanti-affinityを無効化
  service:
    type: NodePort
    nodePort: 31100
ingester:
  replicas: 3 # To ensure data durability with replication
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
  zoneAwareReplication:
    enabled: false
  affinity: # defaultのanti-affinityを無効化（insgesterの場合、zoneAwareReplication.enabled: falseも必要）
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchLabels:
          app.kubernetes.io/component: ingester
  persistence:
    enabled: true
querier:
  replicas: 3 # Improve query performance via parallelism
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
  maxUnavailable: 2
  affinity: # defaultのanti-affinityを無効化
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchLabels:
          app.kubernetes.io/component: querier
queryFrontend:
  replicas: 2
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
  maxUnavailable: 1
queryScheduler:
  replicas: 2
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
distributor:
  replicas: 3 
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
  maxUnavailable: 2
  affinity: # defaultのanti-affinityを無効化
  topologySpreadConstraints:
    - maxSkew: 1
      topologyKey: kubernetes.io/hostname
      whenUnsatisfiable: ScheduleAnyway
      labelSelector:
        matchLabels:
          app.kubernetes.io/component: distributor
compactor:
  replicas: 1
  retention_enabled: true
  working_directory: /tmp/loki/retention
  delete_request_store: s3
  retention_delete_delay: 2h
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
  persistence:
    enabled: true
indexGateway:
  replicas: 2
  extraEnv:
    - name: JAEGER_ENDPOINT
      value: "http://multi-tenant-tempo-distributor.monitoring.svc.cluster.local:14268/api/traces"
    - name: JAEGER_SAMPLER_TYPE
      value: "const"
    - name: JAEGER_SAMPLER_PARAM
      value: "1.0"
  maxUnavailable: 1
  persistence:
    enabled: true
ruler:
  enabled: true
  replicas: 1
  persistence:
    enabled: true
    size: 10Gi
  directories:
    homelab:
      rules.yaml: |
        groups:
          - name: metrics-from-logs
            rules:
              - record: loki:log_lines:1m
                expr: |
                  count_over_time({app="loki"}[1m])
                labels:
                  tenant: "homelab"
    testtenant:
      rules.yaml: |
        groups:
          - name: error-metrics
            rules:
              - record: loki:loki-gateway-rate:5m
                expr: |
                  rate({pod=~"loki-gateway-.*"}[5m]) or vector(0)
                labels:
                  tenant: "testtenant"

# Disable (set 0) components that are not needed in Microservices Mode
test:
  enabled: false
lokiCanary:
  enabled: false
bloomPlanner:
  replicas: 0
bloomBuilder:
  replicas: 0
bloomGateway:
  replicas: 0

backend:
  replicas: 0
read:
  replicas: 0
write:
  replicas: 0

singleBinary:
  replicas: 0
```

